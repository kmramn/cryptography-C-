
#define NOMINMAX 

#include <Windows.h>
#include <winerror.h>

#include <stdio.h>

#include <iostream>
using namespace std;

#include <tchar.h>
#include <strsafe.h>

#include "gmp.h"
#include "gmpxx.h"
#pragma comment(lib, "mpir.lib")
#pragma comment(lib, "mpirxx.lib")

string HexToStr(string szHex)
{
    string szMsg;
    for (int i = 0; i < szHex.length(); i += 2)
    {
        string szSub = szHex.substr(i, 2);
        //char ch = stoul(szSub, nullptr, 16);
        char ch = stoul(szSub, nullptr, 16);
        szMsg += ch;
    }
    return szMsg;
}
void wmain()
{
    //mpz_class N("4");
    //mpz_sqrt(N.get_mpz_t(), N.get_mpz_t());
    //cout << N.get_str() << endl;

    //mpz_class N("720062263747350425279564435525583738338084451473999841826653057981916355690188337790423408664187663938485175264994017897083524079135686877441155132015188279331812309091996246361896836573643119174094961348524639707885238799396839230364676670221627018353299443241192173812729276147530748597302192751375739387929");
    //cout << "N=" << N.get_str() << endl;
    //mpz_class N11 = 24 * N;
    //cout << "N11=" << N11.get_str() << endl;
    //mpz_class A11 = N11;// +1;
    //mpz_sqrt(A11.get_mpz_t(), A11.get_mpz_t());
    ////A11 -= 1;
    //A11++;
    //cout << "A11=" << A11.get_str() << endl;

    //mpz_class AS11 = A11 * A11;
    //cout << "AS11=" << AS11.get_str() << endl;
    //mpz_class XS11 = AS11 - N11;
    //cout << "XS11=" << XS11.get_str() << endl;
    //mpz_abs(XS11.get_mpz_t(), XS11.get_mpz_t());
    //cout << "XS11=" << XS11.get_str() << endl;
    //mpz_class X11;
    //mpz_sqrt(X11.get_mpz_t(), XS11.get_mpz_t());
    //mpz_class p = (A11 - X11) / 6;
    //mpz_class q = (A11 + X11) / 4;
    //mpz_class NN = p * q;
    //cout << "N=" << NN.get_str() << endl;

    // Dan bohne problem 3
    //mpz_class N("720062263747350425279564435525583738338084451473999841826653057981916355690188337790423408664187663938485175264994017897083524079135686877441155132015188279331812309091996246361896836573643119174094961348524639707885238799396839230364676670221627018353299443241192173812729276147530748597302192751375739387929");
    // Professor problem
    //mpz_class N("139985042453534191530814338630181605151083085316793042716222557353976947315273177835521525749840053133030855380542806571666507770967095566644784849872363216671790790178991932306774136746501625197899629158716598807039762413315491667057829160271196105730383640876012723708906672870020514209809347940669608802423", 10);
    // Two close p and q
    //mpz_class N("136701171352748557830760791067094073451052752717330296857467287200427749314688454994360294350385596122243967672715335028160598238200895345922797530312396745491689826853365977473725783879527408074801633878039202701433848516058779075653300544455805093591770085766567220922624447839794244041182174834468239418523508132628744093505717521147160971200603715003151751886388844464932266838293285430712855198360974646067185622889757250895084703639429041058326244602411902487375446393625783743150871753908919608453260992063933086734839992233325992420411688316184850547339388499687172619115939250683065781302905802126052055808866428258650488029895910490946668631754462638124883695950871647713424586096253131092671533527579092847456071416134716545994659417281375767352458264238788445493858508124990806219674021510945552746879327492644954218490432895918798690629346923691997435221119109898358147413915749276844961998270341825754937070272182434217335516213456815277434308859298156791202509872302907767020221239800122335505828088791276814888067799368784185042123424066859291520726360064165160901934669087615765295620629670332530825977661490495898813476122860482164077425517280069575722481280894249959822704712787003775120288914632308253494931205551");
    // Two close p and q wit 4 step q
    //mpz_class N("136701171352748557830760791067094073451052752717330296857467287200427749314688454994360294350385596122243967672715335028160598238200895345922797530312396745491689826853365977473725783879527408074801633878039202701433848516058779075653300544455805093591770085766567220922624447839794244041182174834468239418523508132628744093505717521147160971200603715003151751886388844464932266838293285430712855198360974646067185622889757250895084703639429041058326244602411902487375446393625783743150871753908919608453260992063933086734839992233325992420411688316184850547339388499687172619115939250683065781302905802126052057497695220669511937281076192897312041770217109817330730356963713479764721327045328660145809039164274436962591638803193782499307017495247503338354093262061986930389507345322428890145202695803558682876715622426886720208081892033099479170827996317632880934192612189849836685519583868298394545582594895162051962615616645038993787229368280004949559370624437635050517203926358307772440201655863984617650828053678216227394269146471246952253188303682121913626353771089503990294968215177136808929362523251587432150951932103201292363772080561352613564524280332997410359485968980097380303863878791846766046814535010778754497833096947");
    // Two different p and q
    mpz_class N("144552498451599634749797215940453120625572257162942864747223429339691759764259707653338391347071741016520912435642050786980567376395576921442089840086265280316527538220478517404043352848994615241560015653817936750691487351941817894466789601465568449737529434115574798765612541427390193916659508606213945026364869265651908380919486027803696637646251938039162875499466090409406008590323923593684940978372759086303614078068046840517918451439514953914188486398771228117325645831487362735755053743579554975954773072768696611841893482651137939500599465305939444639504787241128312982686159493341732338691874643414193516545689958487964192494594420614459675331428236264982731851957426434330345199613314411439419240915257416894908218285901416221539897031751240381106913585215504291985271796026296080214682629920910675237208158324129407441023012030827450245804365908389657020468680774033787067159008124860090492625374399198340935181494756182952832016883766119922487693511238415199423573784948024412235741931214334175847982758945219013255669016683923067286548080536351761513326438787519965105442668998704935979116021106677315575622813033635949754673008724806025543011305471987151082608329187194085522179456958799784677405520237260724615220501893");
    cout << "Please input the public modulo N: ";
    string szN;
    cin >> szN;
    N = szN;
    //cout << "N=" << N.get_str() << endl;
    mpz_class A = N + 1;
    mpz_sqrt(A.get_mpz_t(), A.get_mpz_t());
    A -= 1;
    //cout << "A=" << A.get_str() << endl;

    mpz_class pow;
    mpz_ui_pow_ui(pow.get_mpz_t(), 2, 128); // 2^128

    mpz_class p, q;
    for (mpz_class i = 0; i < pow; i++)
    {
        mpz_class AS = A * A;
        //cout << "AS=" << AS.get_str() << endl;
        mpz_class XS = AS - N;
        //cout << "XS=" << XS.get_str() << endl;
        mpz_abs(XS.get_mpz_t(), XS.get_mpz_t());
        //cout << "XS=" << XS.get_str() << endl;
        mpz_class X;
        mpz_sqrt(X.get_mpz_t(), XS.get_mpz_t());
        p = A - X;
        q = A + X;
        mpz_class NN = p * q;
        if (N == NN)
        {
            cout << endl << "The prime factors of N are:" << endl << endl;
            cout << "iteration:" << i.get_str() << endl << endl;
            cout << "p=" << p.get_str() << endl << endl;
            cout << "q=" << q.get_str() << endl << endl;
            //cout << "N=" << NN.get_str() << endl;
            break;
        }
        A++;
    }
    mpz_class e(0);
    // 2 ^ 16 + 1 = 65537 // A prime number.
    e=65537;
    //printmpz(e);
    cout << "Please input the public component e: ";
    string sze;
    cin >> sze;
    e = sze;
    if (e != 0)
    {
        cout << "e = " << e.get_str() << " (PUBLIC KEY)" << endl << endl;

        mpz_class enc("75940355774960532982739727751127039115335871125381475899426558653756383406957895131710664127176935900976315545954910024323744491841477605152081973930895107893247104493552893890193283912558513995861529104760627932151657830603055827610345212590943506302746823964240665504252713259356862520153054934758430461775", 10);
        cout << "Please input the cypher test: ";
        string szenc;
        cin >> szenc;
        enc = szenc;
        //cout << "e = " << e.get_str() << " (PUBLIC KEY)" << endl << endl;

        mpz_class phi;
        phi = (p - 1) * (q - 1);
        //printmpz(phi);

        // Calculate the private key d. d and n together form the private key.
        // d = (e ^ -1) mod phi. d is the inverse of e mod phi.
        mpz_class d;
        //mpz_powm_ui(d, e, -1, phi); // This was giving wrong result. It worked for small number.
        mpz_invert(d.get_mpz_t(), e.get_mpz_t(), phi.get_mpz_t()); // So I used mpz_invert to sinf the inverse of e.
                               //printmpz(d);
        cout << endl << "d = " << d.get_str() << " (PRIVATE KEY)" << endl << endl;

        // Decrypte the encrypted message enc using the PRIVATE KEY d such that
        // dec = (enc ^ d) mod n
        mpz_class dec;
        mpz_powm(dec.get_mpz_t(), enc.get_mpz_t(), d.get_mpz_t(), N.get_mpz_t());
        cout << "dec = " << dec.get_str() << " (DECRYPTED MESSAGE)" << endl; // Print the hexa decimal decrypted message value.
                                                                     // It should be same as the actual hexa decimal original message.
                                                                     // Print the decrypted message.
        string szMsg = "";
        szMsg = HexToStr(dec.get_str(16));
        cout << "msg = " << szMsg.c_str() << " (MESSAGE)" << endl;
    }

    //mpz_class p;
    //mpz_set_str(p.get_mpz_t(), "5C9E2F2AA0E5307D632844A4626E277842C7E17E205571D74138748A8258D44A57697E1CF56E7F07659F8EB5F2173A9949374A9D2BBE65E2C212DEA6A26DCBFB2F986B87C0E10122F5C68D32FFBA10A8A15721F3B33277CF32E195906CB225AF85E93BEC38050F0383618CA686498E624674ED33FF459FF98EF460BBAB3035E3AE32F91A0524A50A5408125EE4FED3134B9F1919BF7DBAB8FF1B9966AAD8D3DA8A628CFE3C9969FD4143632012E8F4EAA2C5756CC53902CAF196F1B8EACF3DD33BE33D613CE2634E0EC8B7692CCEDEDF3462FFCCB5C435392FC0253F3344829F3B0A84D620BF7F0D079B9FFEA2BB441A9CE7FC6D6874FF8EB0B78EF5276D1149", 16);
    //mpz_nextprime(p.get_mpz_t(), p.get_mpz_t());
    ////for (int i = 0; i < 4294967295; i++)
    //mpz_class qT = p;
    //mpz_class q = qT;
    //mpz_class mdif;
    //mpz_ui_pow_ui(mdif.get_mpz_t(), 2, 1040); // 2^32
    ////mpz_ui_pow_ui(mdif.get_mpz_t(), 2, 1035); // 2^32
    //cout << "dif=" << mdif.get_str() << endl;
    ////mpz_class dif = qT - p;
    ////while (dif < mdif)
    ////{
    ////    q = qT;
    ////    mpz_nextprime(qT.get_mpz_t(), qT.get_mpz_t());
    ////    dif = qT - p;
    ////    //cout << "dif=" << dif.get_str() << endl;
    ////}
    //// Or
    //q = p + mdif;
    //mpz_nextprime(q.get_mpz_t(), q.get_mpz_t());

    //mpz_class p;
    //mpz_class q;
    //mpz_set_str(p.get_mpz_t(), "11691927614929394431414113998548678886893624153161127126505862769184260313622920131878465962626600588076452712244101929231766721761222107720438381898852310919698261255830615588628987903092496837045012851312164172731228652343726154637646414177078597127599426027248978694429022099353531815676555097846475430101252696287867799643551513549816344916104269747987173677647074682229828999338263021394326832543857044525300505395496541654670398665777846519219251941313071770578168934300417608510105936512290264056139225378781433590528481333256282361933335846784413576451806153844032431123197682180242799469175738545529762419359", 10);
    //mpz_set_str(q.get_mpz_t(), "11691927614929394431414113998548678886893624153161127126505862769184260313622920131878465962626600588076452712244101929231766721761222107720438381898852310919698261255830615588628987903092496837045012851312164172731228652343726154637646414177078597127599426027248978694429022099353531815676555097846475430469420250307670097546513216623408610361065955035371559773631880893266349049004235517181288388834490815779293731372110138139871845197703089384570789890956078496246814668424931454377051679864291020696053111248873248171061078770620263620507386234398595286993652035876771226535157364186701791771985501615940795439303", 10);
    mpz_class n = p*q;
    mpz_class a = (p + q) / 2;
    mpz_class sn = n + 1;
    mpz_sqrt(sn.get_mpz_t(), sn.get_mpz_t());
    sn = sn - 1;
    mpz_class dif = a - sn;
    cout << "p=" << p.get_str() << endl;
    cout << "q=" << q.get_str() << endl;
    cout << "n=" << n.get_str() << endl;
    cout << "a=" << a.get_str() << endl;
    cout << "sn=" << sn.get_str() << endl;
    cout << "dif=" << dif.get_str() << endl;

    //mpz_set_str(q.get_mpz_t(), "61EFF5E4AA2E336BF555EFF06E23588DCD128DBB03A4FA4F745753ABEAABC2E42B8B30513E74DA313413EEF8C4565C31F506DC24F44E7A2DE18A1C6020746CC75CFCB0B2F4AA57088AA048C0865EB87134A8515797E6BF051F9CCB17A769213012D07D74EF4BA3A6CE73C3B8A9C496E0DB5DF9D3ACF829787C9F1348E489B9D3D978147267B5E889160C01B761C4D878A3696ADF082894AA025DAD0F9B75B0A70027CDDC15C8CF6B0579C981742D461B2EDEE59AA4CD621DA32C9F0B7C8D8A1E1396481BBEECC36CD6DD57BB60A6573CD1D23098969A5162CAA8AC391BC6878FA7BE42A6FAE0EDBA21528A97C52B03700E5BABA1C7BBE32A9F4CAEDAE94D1FF9", 16);
    //mpz_nextprime(q.get_mpz_t(), q.get_mpz_t());
    //cout << "q=" << q.get_str() << endl;
}

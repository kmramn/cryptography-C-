/*
1.Your goal in this project is to break RSA when the public modulus N is generated incorrectly.
This should serve as yet another reminder not to implement crypto primitives yourself.

Normally, the primes that comprise an RSA modulus are generated independently of one another.
But suppose a developer decides to generate the first prime p by choosing a random number R
and scanning for a prime close by. The second prime q is generated by scanning for some other
random prime also close to R.

We show that the resulting RSA modulus N=pq can be easily factored.

Suppose you are given a composite N and are told that N is a product of two relatively close
primes p and q, namely p and q satisfy

     ∣p − q∣< 2*N^(1/4)    (*)

Your goal is to factor N.

Let A be the arithmetic average of the two primes, that is A=(p+q)/2​. Since p and q are odd,
we know that p+q is even and therefore A is an integer.

To factor N you first observe that under condition (*) the quantity sqrt(N)​ is very close to A.
In particular, we show below that:

A−sqrt(N) < 1

But since A is an integer, rounding sqrt(N)​ up to the closest integer reveals the value of A.
In code, A=ceil(sqrt(N)) where "ceil" is the ceiling function.

Visually, the numbers p,q,sqrt(N) and A are ordered as follows:

---|-----------------------|------|---------------------------|---
   p                    sqrt(N)  A=(p+q)/2                    q

Since A is the exact mid-point between p and q there is an integer x such that p=A−x and q=A+x.

But then N=pq=(A−x)(A+x)=A^2−x^2 and therefore x=sqrt(A^2−N).

Now, given x and A you can find the factors p and q of N since p=A−x and q=A+x. You have now
factored N!

Further reading: the method described above is a greatly simplified version of a much more general
http://dl.acm.org/citation.cfm?id=1754517 result on factoring when the high order bits of the prime factor are known.

//In the following challenges, you will factor the given moduli using the method outlined above.
//To solve this assignment it is best to use an environment that supports multi-precision arithmetic
//and square roots. In Python you could use the gmpy2 module. In C you can use GMP.

Factoring challenge #1:

The following modulus N is a products of two primes p and q where ∣p−q∣<2*N^(1/4). Find the smaller
of the two factors and enter it as a decimal integer in the box below.

N = 17976931348623159077293051907890247336179769789423065727343008115 \
77326758055056206869853794492129829595855013875371640157101398586 \
47833778606925583497541085196591615128057575940752635007475935288 \
71082364994994077189561705436114947486504671101510156394068052754 \
0071584560878577663743040086340742855278549092581

For completeness, let us see why A-sqrt(N) < 1. This follows from the following simple calculation.

First observe that A^2−N=((p+q)/2)^2 − N = (p^2+2*N+q^2)/4 - N = (p^2-2*N+q^2)/4 = (p-q)^2/4

Now, since for all x,y: (x−y)(x+y)=x^2−y^2 we obtain A-sqrt(N) = (A - sqrt(N)) * ((A + sqrt(N))\(A + sqrt(N))) = ((A^2 - N)/(A + sqrt(N))) = (((p-q)^2/4)/(A + sqrt(N))).

Since sqrt(N) <= A it follows that A - sqrt(N) <= (((p-q)^2/4)/(2*sqrt(N))) = ((p-q)^2/8*sqrt(N)).

By assumption (*) we know that (p-q)^2 < 4*sqrt(N)​ and therefore A - sqrt(N) <= (4*sqrt(N)/8*sqrt(N)) = 1/2
as required.

Enter the answer for factoring challenge #1 in the box below: 

mpz_sqrt, mpz_sqrtrem, mpf_sqrt

2. Factoring challenge #2:

The following modulus N is a products of two primes p and q where ∣p−q∣<2^11*N^(1/4).
Find the smaller of the two factors and enter it as a decimal integer.

Hint: in this case A−sqrt(N)<2^20 so try scanning for A from sqrt(N)​ upwards, until you succeed
in factoring N.

N = 6484558428080716696628242653467722787263437207069762630604390703787 \
9730861808111646271401527606141756919558732184025452065542490671989 \
2428844841839353281972988531310511738648965962582821502504990264452 \
1008852816733037111422964210278402893076574586452336833570778346897 \
15838646088239640236866252211790085787877

3. Factoring challenge #3:

The following modulus N is a product of two primes p and q where ∣3*p−2*q∣<N^(1/4).
Find the smaller of the two factors and enter it as a decimal integer.

Hint: first show that sqrt(6N)​ is close to 3*p+2*q / 2  and then adapt the method in challenge #1
to factor N.

N = 72006226374735042527956443552558373833808445147399984182665305798191 \
63556901883377904234086641876639384851752649940178970835240791356868 \
77441155132015188279331812309091996246361896836573643119174094961348 \
52463970788523879939683923036467667022162701835329944324119217381272 \
9276147530748597302192751375739387929

4. The challenge ciphertext provided below is the result of encrypting a short secret ASCII
plaintext using the RSA modulus given in the first factorization challenge. 

The encryption exponent used is e=65537. The ASCII plaintext was encoded using PKCS v1.5
before the RSA function was applied, as described in PKCS
https://www-origin.coursera.org/learn/crypto/lecture/JwjDq/pkcs-1.

Use the factorization you obtained for this RSA modulus to decrypt this challenge ciphertext
and enter the resulting English plaintext in the box below. Recall that the factorization of N
enables you to compute φ(N) from which you can obtain the RSA decryption exponent.

Challenge ciphertext (as a deciml intiger):
22096451867410381776306561134883418017410069787892831071731839143676135600120538004282329650473509424343946219751512256465839967942889460764542040581564748988013734864120452325229320176487916666402997509188729971690526083222067771600019329260870009579993724077458967773697817571267229951148662959627934791540

After you use the decryption exponent to decrypt the challenge ciphertext you will obtain a PKCS1
encoded plaintext. To undo the encoding it is best to write the decrypted value in hex.
You will observe that the number starts with a '0x02' followed by many random non-zero digits.
Look for the '0x00' separator and the digits following this separator are the ASCII letters of
the plaintext.

(note: the separator used here is '0x00', not '0xFF' as stated in the lecture)
*/
#define NOMINMAX
#include <Windows.h>
#include <tchar.h>
#include <strsafe.h>

#include <iostream>
using namespace std;

#include <stdio.h>

#include <gmp.h>
#include <gmpxx.h>
#include <iomanip>
#pragma comment(lib, "libgmp.a")
#pragma comment(lib, "libgmpxx.a")
#pragma comment(lib, "libgcc.a")

void PrintGMPZ(mpz_t mpzN, int nBase = 10)
{
    char szBuffer[1024];
    SecureZeroMemory(szBuffer, sizeof(szBuffer));
    mpz_get_str(szBuffer, nBase, mpzN);
    wprintf(L"%S\n", szBuffer);
}

void PrintGMPZ(mpf_t mpzN, int nBase = 10)
{
    char szBuffer[1024];
    SecureZeroMemory(szBuffer, sizeof(szBuffer));
    mp_exp_t expptr = 6;
    mpf_get_str(szBuffer, &expptr, nBase, 1022, mpzN);
    wprintf(L"%S.%d\n", szBuffer, expptr);
    /*mpf_class mpfc(mpzN);
    cout << "ABC" << mpfc << endl;*/
}

void PrintGMPZ(mpq_t mpzN, int nBase = 10)
{
    char szBuffer[1024];
    SecureZeroMemory(szBuffer, sizeof(szBuffer));
    mpq_get_str(szBuffer, nBase, mpzN);
    wprintf(L"%S\n", szBuffer);
    /*mpf_class mpfc(mpzN);
    cout << "ABC" << mpfc << endl;*/
}

void wmain()
{
    char szN1[] = "17976931348623159077293051907890247336179769789423065727343008115 \
        77326758055056206869853794492129829595855013875371640157101398586 \
        47833778606925583497541085196591615128057575940752635007475935288 \
        71082364994994077189561705436114947486504671101510156394068052754 \
        0071584560878577663743040086340742855278549092581";
    //char szN1[] = "77";
    char szN2[] = "6484558428080716696628242653467722787263437207069762630604390703787 \
        9730861808111646271401527606141756919558732184025452065542490671989 \
        2428844841839353281972988531310511738648965962582821502504990264452 \
        1008852816733037111422964210278402893076574586452336833570778346897 \
        15838646088239640236866252211790085787877";
    char szN3[] = "72006226374735042527956443552558373833808445147399984182665305798191 \
        63556901883377904234086641876639384851752649940178970835240791356868 \
        77441155132015188279331812309091996246361896836573643119174094961348 \
        52463970788523879939683923036467667022162701835329944324119217381272 \
        9276147530748597302192751375739387929";
    // p = 1166083 q = 1749149
    //char szN3[] = "2039652913367";

    unsigned long ule = 65537;
    unsigned long uld = 0;
    //char szCT[] = { 22, 09, 64, 51, 86, 74, 10, 38, 17, 76, 30, 65, 61, 13, 48, 83, 41, 80, 17, 41, 00, 69, 78, 78, 92, 83, 10, 71, 73, 18, 39, 14, 36, 76, 13, 56, 00, 12, 05, 38, 00, 42, 82, 32, 96, 50, 47, 35, 09, 42, 43, 43, 94, 62, 19, 75, 15, 12, 25, 64, 65, 83, 99, 67, 94, 28, 89, 46, 07, 64, 54, 20, 40, 58, 15, 64, 74, 89, 88, 01, 37, 34, 86, 41, 20, 45, 23, 25, 22, 93, 20, 17, 64, 87, 91, 66, 66, 40, 29, 97, 50, 91, 88, 72, 99, 71, 69, 05, 26, 08, 32, 22, 06, 77, 71, 60, 00, 19, 32, 92, 60, 87, 00, 09, 57, 99, 93, 72, 40, 77, 45, 89, 67, 77, 36, 97, 81, 75, 71, 26, 72, 29, 95, 11, 48, 66, 29, 59, 62, 79, 34, 79, 15, 40 };
    char szCT[] = { "22096451867410381776306561134883418017410069787892831071731839143676135600120538004282329650473509424343946219751512256465839967942889460764542040581564748988013734864120452325229320176487916666402997509188729971690526083222067771600019329260870009579993724077458967773697817571267229951148662959627934791540" };

    //char szTest1[] = "1.77663743040086340742855278549092581";

    //mpf_t mpfN1;
    //mpf_init(mpfN1);
    //mpf_set_str(mpfN1, szN1, 10);
    ////mpf_set_str(mpfN1, szTest1, 10);

    //char szBuffer[1024];
    //mp_exp_t mpExp;
    //SecureZeroMemory(szBuffer, sizeof(szBuffer));
    //mpf_get_str(szBuffer, &mpExp, 10, sizeof(szBuffer), mpfN1);
    //wprintf(L"%u - %S\n", sizeof(szBuffer), szBuffer);

    //mpf_t mpfSqrtN1;
    //mpf_init(mpfSqrtN1);
    //mpf_sqrt(mpfSqrtN1, mpfN1);

    //mpf_t mpfA1;
    //mpf_init(mpfA1);
    //mpf_ceil(mpfA1, mpfN1);

    //mpf_clear(mpfA1);
    //mpf_clear(mpfN1);

    // Challenge 1
    mpz_t mpzN1;
    mpz_init(mpzN1);
    mpz_set_str(mpzN1, szN1, 10);
    PrintGMPZ(mpzN1);

    mpz_t mpzA1;
    mpz_init(mpzA1);

    mpz_sub_ui(mpzA1, mpzN1, 1);
    //PrintGMPZ(mpzA1);
    mpz_sqrt(mpzA1, mpzA1);
    //PrintGMPZ(mpzA1);
    mpz_add_ui(mpzA1, mpzA1, 1);
    //PrintGMPZ(mpzA1);

    mpz_t mpzAS1;
    mpz_init(mpzAS1);
    mpz_pow_ui(mpzAS1, mpzA1, 2);
    //A^2 = N + 2*sqrt(N-1)
    //mpz_init(mpzAS1);
    //mpz_sub_ui(mpzAS1, mpzN1, 1);
    //mpz_sqrt(mpzAS1, mpzAS1);
    //mpz_mul_ui(mpzAS1, mpzAS1, 2);
    //mpz_add(mpzAS1, mpzAS1, mpzN1);

    mpz_t mpzx1;
    mpz_init(mpzx1);
    mpz_sub(mpzx1, mpzAS1, mpzN1);
    mpz_sub_ui(mpzx1, mpzx1, 1);
    mpz_sqrt(mpzx1, mpzx1);
    mpz_add_ui(mpzx1, mpzx1, 1);
    //mpz_sub_ui(mpzx1, mpzN1, 1);
    //mpz_sqrt(mpzx1, mpzx1);
    //mpz_mul_ui(mpzx1, mpzx1, 2);
    //mpz_sqrt(mpzx1, mpzx1);

    mpz_t mpzp1;
    mpz_t mpzq1;
    mpz_init(mpzp1);
    mpz_init(mpzq1);
    mpz_sub(mpzp1, mpzA1, mpzx1);
    mpz_add(mpzq1, mpzA1, mpzx1);
    //mpz_t mpzNSM1;
    //mpz_init(mpzNSM1);
    //mpz_set(mpzNSM1, mpzN1);
    //mpz_sub_ui(mpzNSM1, mpzNSM1, 1);
    //mpz_sqrt(mpzNSM1, mpzNSM1);

    //mpz_t mpzNSSM1;
    //mpz_init(mpzNSSM1);
    //mpz_set(mpzNSSM1, mpzNSM1);
    //mpz_mul_ui(mpzNSSM1, mpzNSSM1, 2);
    //mpz_sqrt(mpzNSSM1, mpzNSSM1);

    //mpz_add_ui(mpzp1, mpzNSM1, 1);
    //mpz_sub(mpzp1, mpzNSM1, mpzNSSM1);
    //mpz_add_ui(mpzq1, mpzNSM1, 1);
    //mpz_add(mpzq1, mpzNSM1, mpzNSSM1);

    PrintGMPZ(mpzp1);
    PrintGMPZ(mpzq1);

    mpz_t mpzpq1;
    mpz_init(mpzpq1);
    mpz_mul(mpzpq1, mpzp1, mpzq1);
    PrintGMPZ(mpzpq1);

    mpz_clear(mpzpq1);

    mpz_clear(mpzx1);
    mpz_clear(mpzAS1);
    mpz_clear(mpzA1);

    printf("\n\n");

    // Challenge 4
    mpz_t mpzCT;
    mpz_init(mpzCT);
    mpz_set_str(mpzCT, szCT, 10);
    PrintGMPZ(mpzCT);

    mpz_t mpze;
    mpz_init(mpze);
    mpz_set_ui(mpze, ule);
    mpz_t mpzd;
    mpz_init(mpzd);

    // TODO: Find mpzd
    mpz_t mpzphin;
    mpz_init(mpzphin);

    mpz_t mpzpm1;
    mpz_init(mpzpm1);
    mpz_t mpzqm1;
    mpz_init(mpzqm1);
    PrintGMPZ(mpzp1);
    PrintGMPZ(mpzq1);
    mpz_sub_ui(mpzpm1, mpzp1, 1);
    mpz_sub_ui(mpzqm1, mpzq1, 1);
    mpz_mul(mpzphin, mpzpm1, mpzqm1);

    mpz_t mpzg;
    mpz_init(mpzg);
    mpz_t mpzk;
    mpz_init(mpzk);
    mpz_gcdext(mpzg, mpzd, mpzk, mpze, mpzphin);
    mpz_add(mpzd, mpzphin, mpzd);
    PrintGMPZ(mpzg);
    PrintGMPZ(mpze);
    PrintGMPZ(mpzd);
    PrintGMPZ(mpzk);
    PrintGMPZ(mpzphin);

    mpz_t mpzm;
    mpz_init(mpzm);
    mpz_powm(mpzm, mpzCT, mpzd, mpzN1);
    PrintGMPZ(mpzCT, 10);
    PrintGMPZ(mpzm, 16);

    char szm[1024];
    char* p = NULL;
    SecureZeroMemory(szm, sizeof(szm));
    mpz_get_str(szm, 16, mpzm);
    p = szm;
    if (szm[0] == '2')
    {
        while ((*p != '0') || *(p + 1) != '0')
        {
            p++;
        }
        p += 2;
        printf("%s\n", p);
    }
    char szm1[128];
    SecureZeroMemory(szm1, sizeof(szm1));
    char sztm1[3];
    SecureZeroMemory(sztm1, sizeof(sztm1));
    int nVal = 0;
    while (*p != 0)
    {
        lstrcpynA(sztm1, p, 3);
        szm1[nVal] = strtol(sztm1, NULL, 16);
        p += 2;
        nVal++;
    }
    printf("%s\n", szm1);

    mpz_clear(mpzphin);
    mpz_clear(mpzpm1);
    mpz_clear(mpzqm1);
    mpz_clear(mpzg);
    mpz_clear(mpzk);

    mpz_clear(mpzm);
    mpz_clear(mpzd);
    mpz_clear(mpze);
    mpz_clear(mpzCT);

    mpz_clear(mpzp1);
    mpz_clear(mpzq1);
    mpz_clear(mpzN1);

    ////char szTest1[] = "3";
    ////mpz_t mpzN1;
    ////mpz_init(mpzN1);
    ////mpz_set_str(mpzN1, szTest1, 10);
    ////PrintGMPZ(mpzN1);
    ////mpz_sqrt(mpzN1, mpzN1);
    ////PrintGMPZ(mpzN1);

    // Challenge 4
    /*mpz_t mpze;
    mpz_init(mpze);
    mpz_set_ui(mpze, 7);
    mpz_t mpzd;
    mpz_init(mpzd);

    mpz_t mpzphin;
    mpz_init_set_ui(mpzphin, 60);

    mpz_t mpzg;
    mpz_init(mpzg);
    mpz_t mpzk;
    mpz_init(mpzk);
    mpz_gcdext(mpzg, mpzd, mpzk, mpze, mpzphin);
    mpz_add(mpzd, mpzphin, mpzd);
    PrintGMPZ(mpzg);
    PrintGMPZ(mpze);
    PrintGMPZ(mpzd);
    PrintGMPZ(mpzk);
    PrintGMPZ(mpzphin);

    mpz_t mpzm;
    mpz_init_set_ui(mpzm, 63);
    mpz_t mpzn1;
    mpz_init_set_ui(mpzn1, 77);
    mpz_powm(mpzm, mpzm, mpze, mpzn1);
    PrintGMPZ(mpzm);
    mpz_powm(mpzm, mpzm, mpzd, mpzn1);
    PrintGMPZ(mpzm);

    mpz_clear(mpzphin);
    mpz_clear(mpzg);
    mpz_clear(mpzk);
    mpz_clear(mpzd);
    mpz_clear(mpze);*/

    printf("\n\n");

    // Challenge 2
    mpz_t mpzN2;
    mpz_init(mpzN2);
    mpz_set_str(mpzN2, szN2, 10);
    PrintGMPZ(mpzN2);

    mpz_t mpzA2;
    mpz_init(mpzA2);

    mpz_t mpzp2;
    mpz_t mpzq2;
    mpz_init(mpzp2);
    mpz_init(mpzq2);

    mpz_t mpzAS2;
    mpz_init(mpzAS2);

    mpz_t mpzx2;
    mpz_init(mpzx2);
    mpz_t mpzpq2;
    mpz_init(mpzpq2);

    // mpzA2 = sqrt(mpzN2)
    //mpz_sub_ui(mpzA2, mpzN2, 1);
    mpz_sqrt(mpzA2, mpzN2);
    //mpz_add_ui(mpzA2, mpzA2, 1);


    long double ldN22 = pow(2, 20);
    unsigned long l2 = 0;
    for (l2 = 0; l2 < ldN22; l2++)
    {
        //sqrt(mpzN2) < mpzA2 < sqrt(mpzN2) + 2^20
        mpz_add_ui(mpzA2, mpzA2, 1);

        // AS2 = A2^2
        mpz_pow_ui(mpzAS2, mpzA2, 2);

        // x = sqrt(a^2 - N) // additionally ceil it
        mpz_sub(mpzx2, mpzAS2, mpzN2);
        //mpz_sub_ui(mpzx2, mpzx2, 1);
        mpz_sqrt(mpzx2, mpzx2);
        //mpz_add_ui(mpzx2, mpzx2, 1);

        // p = A - x
        mpz_sub(mpzp2, mpzA2, mpzx2);
        // p = A + x
        mpz_add(mpzq2, mpzA2, mpzx2);

        //PrintGMPZ(mpzp2);
        //PrintGMPZ(mpzq2);

        // N = p * q / used to verify with he original N
        mpz_mul(mpzpq2, mpzp2, mpzq2);
        if (mpz_cmp(mpzN2, mpzpq2) == 0)
        {
            PrintGMPZ(mpzpq2);
            PrintGMPZ(mpzp2);
            PrintGMPZ(mpzq2);
            printf("%d\n", l2);
            break;
        }
    }
    mpz_clear(mpzpq2);
    mpz_clear(mpzx2);
    mpz_clear(mpzAS2);
    mpz_clear(mpzA2);
    mpz_clear(mpzp2);
    mpz_clear(mpzq2);
    mpz_clear(mpzN2);

    printf("\n\n");

    // Challenge 3
    /*mpq_t mpqN3;
    mpq_init(mpqN3);
    mpq_set_str(mpqN3, "3/2", 10);
    PrintGMPZ(mpqN3);*/

    mpf_set_default_prec(10000);
    mpf_t mpzN3;
    mpf_init(mpzN3);
    mpf_set_str(mpzN3, szN3, 10);
    //mpf_set_str(mpzN3, "342561.52345", 10);
    PrintGMPZ(mpzN3);

    // 6*N
    mpf_t mpzN63;
    mpf_init(mpzN63);
    mpf_mul_ui(mpzN63, mpzN3, 6);
    PrintGMPZ(mpzN63);

    // AP = sqrt(6*N)
    mpf_t mpzA3;
    mpf_init(mpzA3);
    //mpf_sub_ui(mpzA3, mpzN63, 1);
    mpf_sqrt(mpzA3, mpzN63);
    //mpf_add_ui(mpzA3, mpzA3, 1);
    PrintGMPZ(mpzA3);
    mpz_t mpzMnt;
    mpz_init(mpzMnt);
    mpz_set_f(mpzMnt, mpzA3);
    PrintGMPZ(mpzMnt);
    mpf_set_z(mpzA3, mpzMnt);
    PrintGMPZ(mpzA3);
    mpf_t mpfP5;
    mpf_init_set_str(mpfP5, ".5", 10);
    mpf_add(mpzA3, mpzA3, mpfP5);
    PrintGMPZ(mpzA3);

    mpf_t mpzAS3;
    mpf_init(mpzAS3);
    // Ap^2
    mpf_pow_ui(mpzAS3, mpzA3, 2);
    PrintGMPZ(mpzAS3);

    // xp = sqrt(Ap^2 - 6*N)
    mpf_t mpzx3;
    mpf_init(mpzx3);
    mpf_sub(mpzx3, mpzAS3, mpzN63);
    PrintGMPZ(mpzx3);
    //mpz_sub_ui(mpzx3, mpzx3, 1);
    mpf_sqrt(mpzx3, mpzx3);
    //mpz_add_ui(mpzx3, mpzx3, 1);
    PrintGMPZ(mpzx3);

    // p = (AP - xp)/3
    // q = (AP + xp)/2
    mpf_t mpzp3;
    mpf_t mpzq3;
    mpf_init(mpzp3);
    mpf_init(mpzq3);
    mpf_sub(mpzp3, mpzA3, mpzx3);
    mpf_div_ui(mpzp3, mpzp3, 3);
    mpf_add(mpzq3, mpzA3, mpzx3);
    mpf_div_ui(mpzq3, mpzq3, 2);

    PrintGMPZ(mpzp3);
    PrintGMPZ(mpzq3);

    mpf_t mpzpq3;
    mpf_init(mpzpq3);
    mpf_mul(mpzpq3, mpzp3, mpzq3);
    PrintGMPZ(mpzpq3);

    mpf_clear(mpzpq3);

    mpf_clear(mpzx3);
    mpf_clear(mpzAS3);
    mpf_clear(mpzA3);

    printf("\n\n");

     // Challenge 3
    mpz_t mpzN31;
    mpz_init(mpzN31);
    mpz_set_str(mpzN31, szN3, 10);
    PrintGMPZ(mpzN31);

    mpz_t mpzA31;
    mpz_init(mpzA31);

    mpz_t mpzNmul31;
    mpz_init(mpzNmul31);
    mpz_mul_ui(mpzNmul31, mpzN31, 24);
    PrintGMPZ(mpzNmul31);
    mpz_sub_ui(mpzA31, mpzNmul31, 1);
    mpz_sqrt(mpzA31, mpzA31);
    mpz_add_ui(mpzA31, mpzA31, 1);
    //PrintGMPZ(mpzA31);

    mpz_t mpzAS31;
    mpz_init(mpzAS31);
    mpz_pow_ui(mpzAS31, mpzA31, 2);
    PrintGMPZ(mpzAS31);

    mpz_t mpzx31;
    mpz_init(mpzx31);
    mpz_sub(mpzx31, mpzAS31, mpzNmul31);
    PrintGMPZ(mpzx31);
    //mpz_sub_ui(mpzx31, mpzx31, 1);
    mpz_sqrt(mpzx31, mpzx31);
    //mpz_add_ui(mpzx31, mpzx31, 1);
    PrintGMPZ(mpzx31);

    mpz_div_ui(mpzA31, mpzA31, 2);

    mpz_t mpzp31;
    mpz_t mpzq31;
    mpz_init(mpzp31);
    mpz_init(mpzq31);
    mpz_sub(mpzp31, mpzA31, mpzx31);
    mpz_div_ui(mpzp31, mpzp31, 3);
    mpz_add(mpzq31, mpzA31, mpzx31);
    mpz_div_ui(mpzq31, mpzq31, 2);

    PrintGMPZ(mpzp31);
    PrintGMPZ(mpzq31);

    mpz_t mpzpq31;
    mpz_init(mpzpq31);
    mpz_mul(mpzpq31, mpzp31, mpzq31);
    PrintGMPZ(mpzpq31);

    mpz_clear(mpzpq31);

    mpz_clear(mpzx31);
    mpz_clear(mpzAS31);
    mpz_clear(mpzNmul31);
    mpz_clear(mpzA31);

    printf("\n\n");
}
